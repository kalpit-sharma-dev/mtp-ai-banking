Great â€” before we create the full thesis, I will produce a **Complete End-to-End Project Document** describing:

âœ” Full system overview
âœ” Architecture
âœ” Functionalities
âœ” Modules
âœ” Workflows
âœ” APIs
âœ” Agents
âœ” ML models
âœ” MCP server design
âœ” Security
âœ” Deployment
âœ” Testing
âœ” Future scope

This document will be **your Master Project Blueprint**, the single most important file that explains your entire project.

I will structure it like an official **Engineering Design Document (EDD)** + **Product Requirement Document (PRD)** + **Solution Architecture Document (SAD)** combined.

---

# âœ… **END-TO-END PROJECT DOCUMENT**

# **AI Banking Using Agentic AI and ML Models Involving MCP Servers**

---

# **1. Project Overview**

Banks today need real-time intelligence, contextual decision-making, multi-agent collaboration, and consistent logic across channels (Mobile Banking, Net Banking, Corporate Banking, API Banking). Traditional rule-based systems cannot achieve this.

This project develops a **unified AI Banking Intelligence Layer** built using:

* **Agentic AI**
* **Machine Learning models**
* **MCP (Model Context Protocol) Server**
* **AI Skin Orchestrator**
* **Agent Mesh**
* **ML-driven banking logic**
* **Secure API integration**

This system becomes the **brain** of a modern bank.

---

# **2. Vision Statement**

To build Indiaâ€™s first **AI-Orchestrated Banking Intelligence Platform** using **Agentic AI + ML + MCP Servers** that enables:

* Real-time fraud detection
* Smart transaction approvals
* Personalized banking actions
* Intelligent credit/risk decisions
* Multi-agent collaboration
* Unified cross-channel logic

---

# **3. Core Components Overview**

The system consists of **7 core subsystems**:

1. **MCP Server (Golang)**
2. **AI Skin Orchestrator**
3. **Agent Mesh (Banking, Fraud, Clearance, Guardrail, Scoring)**
4. **ML Models (Fraud, Risk, Recommendation)**
5. **Banking Application Integrations (MB, NB, DWH)**
6. **Event and Streaming Backbone (Kafka/PubSub)**
7. **Observability + Security**

---

# **4. High-Level Architecture**

```
Mobile Banking / Net Banking Apps / Backend Apps
            |
            v
        API Gateway
            |
            v
      MCP Server (Golang)
   -----------------------------------
   |           |           |         |
   |     AI Skin Orchestrator        |
   -----------------------------------
   |     |        |         |        |
   v     v        v         v        v
Banking Agent | Fraud Agent | Guardrail Agent |
Clearance Agent | Scoring Agent
   |     |        |         |        |
   v     v        v         v        v
      ML MODELS + RULE ENGINES
            |
            v
       Databases + DWH + Logs
```

---

# **5. Functional Requirements**

### **5.1 MCP Server**

* Manages context for every request
* Maintains session state
* Calls appropriate agents
* Provides structured responses
* Ensures security between agents
* Logs trace for each action

### **5.2 AI Skin Orchestrator**

* Takes input from users or apps
* Understands intent
* Chooses the correct agent
* Merges multi-agent outputs
* Handles conflict resolution

### **5.3 Agent Mesh**

#### **A. Banking Agent**

Handles:

* Fund transfer flows
* Balance check
* Statement generation
* Bill payments
* Transaction simulations

#### **B. Guardrail Agent**

Implements:

* RBI regulations
* Bank policy rules
* User-level restrictions
* Suspicious entity detection
* Velocity rules

#### **C. Fraud Agent**

Uses ML + behavior biometrics + pattern detection:

* Suspicious transfers
* New beneficiary risk
* Sudden large amounts
* Device anomaly
* Geo-location mismatch

#### **D. Clearance Agent**

Executes:

* Loan approval flows
* Manual review replacements
* Complex multi-step decisions

#### **E. Scoring Agent**

Calls ML Models:

* Credit risk score
* Fraud risk score
* Transaction risk scoring
* User behavior analysis

---

# **6. Non-Functional Requirements**

| Requirement    | Description                                 |
| -------------- | ------------------------------------------- |
| Scalability    | Must support millions of daily transactions |
| Security       | Banking-grade encryption, RBAC              |
| Availability   | 99.95% uptime                               |
| Latency        | <200ms for real-time decisions              |
| Consistency    | Same decision across MB, NB                 |
| Auditability   | Full trail stored in DB                     |
| Explainability | Each decision must include reasoning        |

---

# **7. Detailed Architecture Components**

---

## **7.1 MCP Server (Golang)**

### Responsibilities:

* Request intake
* Session management
* Context tracking
* Agent selection
* Tool calling
* Response packaging

### Internal Modules:

1. **Session Manager**
2. **Context Store**
3. **Agent Dispatcher**
4. **Security Validation**
5. **Logging & Tracing**
6. **Error Handler**

---

## **7.2 AI SKIN Orchestrator**

The brain that:

* Reads intent
* Reads user history
* Evaluates risk
* Chooses agent path
* Merges responses

Algorithm Steps:

1. Parse request
2. Extract intent + entities
3. Fetch session context
4. Evaluate risk using Scoring Agent
5. Check rules via Guardrail Agent
6. If passed â†’ Banking Agent
7. If suspicious â†’ Fraud Agent
8. If loan â†’ Clearance Agent
9. Output final message

---

## **7.3 Agent Mesh Design**

Each agent follows:

* Intent patterns
* Tools
* ML model integration
* Rules
* Observability

### Example Structure:

```
agent {
 name: "FraudAgent"
 tools: ["FraudModel", "BehaviorModel"]
 responsibilities: ["detect_fraud", "analyze_patterns"]
 context_required: true
}
```

---

# **8. ML Models Used**

## **8.1 Fraud Detection Model**

* Algorithm: XGBoost or LSTM
* Inputs:

  * Transaction amount
  * History
  * Device fingerprint
  * Geo-location
  * Time of day
  * User behavior metrics

## **8.2 Credit/Risk Scoring Model**

* Algorithm: Logistic Regression / Random Forest
* Features:

  * Income
  * Account age
  * Delinquency
  * Past loans
  * Spending behavior

## **8.3 Recommendation Model**

* Algorithm: Collaborative filtering
* Recommends:

  * Loan products
  * Credit card upgrades
  * Investment suggestions

---

# **9. Banking Workflows**

---

## **9.1 Transaction Flow (NEFT Example)**

### Step-by-Step:

1. User initiates NEFT on MB/NB
2. API Gateway â†’ MCP Server
3. Session created
4. AI Skin identifies intent
5. Guardrail Agent checks:

   * Daily limit
   * Velocity
   * Beneficiary age
6. Scoring Agent calculates risk score
7. If high â†’ Fraud Agent
8. If safe â†’ Banking Agent executes transaction
9. MCP Server sends final structured response

---

## **9.2 Fraud Detection Flow**

1. User attempts large transfer
2. MCP â†’ Scoring Agent
3. Risk score > threshold
4. Fraud Agent runs:

   * Device anomaly check
   * Historical behavior model
   * Time/location mismatch
5. If suspicious:

   * Apply step-up authentication
   * Block transaction
   * Raise fraud case

---

## **9.3 Loan Approval Flow**

1. User requests loan
2. MCP â†’ Clearance Agent
3. Scoring Agent â†’ credit score
4. Policy check using Guardrail Agent
5. Reports created
6. Approval decision made

---

# **10. API Design**

---

## **10.1 Example API â€“ Process Transaction**

**Endpoint:**
`POST /mcp/process`

**Request:**

```json
{
  "sessionId": "abc123",
  "userId": "U10001",
  "channel": "MB",
  "intent": "TRANSFER_NEFT",
  "data": {
    "amount": 50000,
    "toAccount": "XXXX4321"
  }
}
```

**Response:**

```json
{
  "status": "APPROVED",
  "riskScore": 0.12,
  "explanation": "Transaction is within user limits and behavior pattern is normal."
}
```

---

# **11. Databases**

## Tables:

* **session_context**
* **risk_scores**
* **fraud_logs**
* **transaction_audit**
* **agent_logs**
* **model_explanations**

---

# **12. Security Architecture**

* OAuth2 / Keycloak
* RBAC for agent access
* Encryption AES-256
* HMAC request signatures
* WAF + Rate limiting
* Audit logging

---

# **13. Deployment Architecture**

### Components:

* Kubernetes cluster
* Golang MCP server pods
* Agent pods
* ML model serving pods
* Kafka/PubSub
* Redis cluster
* Postgres DB
* Prometheus + Grafana
* Jaeger Tracing

---

# **14. Testing Strategy**

### A. Unit Testing

* Each agent
* MCP modules
* ML model endpoints

### B. Integration Testing

* Multi-agent flow
* Intents
* DWH

### C. Load Testing

* Latency under 10K TPS

---

# **15. Future Enhancements**

* Full LLM integration for conversational banking
* Autonomous Bank AI Agent
* Self-learning fraud patterns
* Federated learning for privacy
* Voice and AR Banking

---

# ğŸ‰ **End-to-End Project Document Completed**

This is your **full project blueprint**.

---



Prompt to Generate MCP Server in Golang:

Create a Golang-based MCP (Model Context Protocol) server for an MTech project titled "AI Banking Using Agentic AI and ML Model". The MCP server should:

Server Purpose:

Act as a central orchestrator to manage AI/ML model execution and communication between banking microservices.

Handle contextual routing and execution of agentic AI tasks like fraud detection, credit scoring, and user personalization.

Functional Requirements:

REST and gRPC endpoints to:

Submit a task (with context metadata and user request)

Retrieve task status and result

Register models or agents

Route requests to the correct model/agent based on context

Support JSON input/output

Store minimal session or request context in memory or a lightweight DB (e.g., SQLite or Redis)

Tech Stack:

Language: Golang

Web Framework: Gorilla Mux or Fiber

gRPC for inter-service communication

Logging: Zerolog or Logrus

Configuration via .env or Viper

Use proper Golang struct layering: controller â†’ service â†’ router â†’ model â†’ utils

Advanced (Optional but Ideal):

Support async task handling (e.g., via channels or background goroutines)

Include Swagger/OpenAPI docs

Plug in ML model inference calls (mocked if needed)

Return example JSON payloads for each endpoint




Background of the Problem

Discuss the need for intelligent, real-time, secure banking.

Mention limitations of traditional systems and the emergence of MCP servers and agentic AI.

Problem Definition

Define the lack of context-aware, modular AI in banking.

Explain challenges in integrating ML models into decision pipelines.

Importance of the Problem

Highlight why AI-driven, explainable, and secure decision systems are critical in modern banking.

Mention fraud risks, regulatory pressure, and customer demand for personalization.

Existing Works in This Direction

Summarize existing AI/ML use in banking (fraud detection, scoring).

Mention LangChain, Function Calling, and ML pipelines in cloud platforms.

State the gap: no unified, agentic AI + MCP system for BFSI.

Your Objectives

Design AI Banking system using MCP and agents.

Integrate fraud detection, loan scoring, and personalization models.

Ensure secure, modular, real-time operation.

Methods/Tools to be Used

Tools: Golang/Python MCP server, agent orchestration (LangGraph/OpenAI style), ML models (Scikit-learn, TensorFlow), Kafka/PubSub, PostgreSQL, GCP for deployment.

Possible Outcomes

Demonstrate reduced fraud risk, real-time decisions, scalable AI banking system.

Deliver architecture and research insights in agentic AI for finance.




1. Background of the Problem

Slide Title: The Rise of AI in Banking

Content:

Modern banking systems are under pressure to deliver secure, fast, and intelligent services.

Traditional systems are often rule-based and not adaptive.

With the explosion of data and the need for real-time decisions, AI-powered banking is emerging as the future.

MCP (Model Context Protocol) servers and agentic AI provide infrastructure to support modular, intelligent decision-making at scale.

2. Problem Definition

Slide Title: The Core Challenge

Content:

Lack of intelligent, context-aware processing in current banking infrastructure.

Difficulty integrating multiple AI/ML models with real-time decision pipelines.

Inability to scale securely and modularly across various banking services (fraud detection, loan approval, personalization).

Need for a central orchestrator (like an MCP server) to manage AI agents and models effectively.

3. Importance of the Problem

Slide Title: Why This Matters

Content:

Financial frauds and risks are increasing, requiring real-time intelligent defenses.

Users demand personalized, predictive, and proactive banking services.

Regulatory and compliance frameworks expect explainability and robustness in AI decision-making.

An agentic AI system using MCP offers modularity, explainability, and scalability.

4. Existing Works in this Direction

Slide Title: What Has Been Done So Far

Content:

Banks using AI for credit scoring, fraud detection, customer segmentation.

FinTechs using microservices with ML APIs but lacking coordination and context-awareness.

OpenAIâ€™s Function Calling and LangChain demonstrate agent orchestration ideas.

Google's Vertex AI and Azure ML pipelines show model lifecycle orchestration.

However, no existing system combines agentic AI + MCP + banking in one secure, scalable platform.

5. Your Objectives

Slide Title: Project Objectives

Content:

Design and implement an AI Banking architecture powered by agentic AI.

Build and integrate MCP Servers to orchestrate multiple models and tools.

Use ML models for fraud detection, user personalization, and loan prediction.

Ensure security, context-awareness, and low-latency decision-making.

Evaluate the system on synthetic and real banking data (anonymized).

6. Possible Methods/Tools to be Used

Slide Title: Tech Stack & Methodology

Content:

MCP Server: Custom-built in Golang or Python for managing context and agents.

Agentic AI: Using OpenAI function-calling-style agents or LangGraph-based routing.

ML Models: Scikit-learn / TensorFlow / PyTorch for fraud, credit scoring.

Backend: Golang-based REST/gRPC microservices.

Data Pipeline: Pub/Sub or Kafka + PostgreSQL.

Deployment: GCP (Cloud Run / Kubernetes), secured using IAM policies.

7. Possible Outcomes

Slide Title: Expected Results

Content:

A prototype system demonstrating modular, intelligent banking decisions.

Reduction in fraud risk via adaptive ML models.

Real-time, explainable decision-making across multiple banking tasks.

Scalable, secure infrastructure using MCP + agents + ML.

Research outcome: A novel architecture for agentic AI in BFSI (Banking/Finance).


1. Background of the Problem

Discuss the growing complexity of banking systems.

Highlight the need for intelligent, secure, context-aware processing.

Mention that traditional rule-based systems struggle to scale with AI/ML demands.

2. Problem Definition

Define the core issue: lack of orchestration between ML models and agent-based services.

Mention challenges like scalability, security, and context-switching in banking decisions.

Emphasize that banking apps (MB/NB/Trade) lack dynamic AI decision pipelines.

3. Importance of the Problem

Customers expect predictive and personalized experiences.

Regulatory needs demand explainable and auditable AI.

Financial frauds are rising, and static rule engines can't adapt fast enough.

4. Existing Works in This Direction

Mention existing tools like:

LangChain, OpenAI Agents (Function Calling)

GCP/Azure ML Pipelines

Cloud-native microservices in FinTech

Highlight that most lack integration of AI orchestration, agents, and context-routing in BFSI.

5. Your Objectives

Build a prototype banking system with:

AI SKIN Orchestrator (Input/Output context, Rule Management, Task Mgmt)

Agentic Mesh (Payment/Banking/Trade Agents, Clearance, Guardrail agents)

MCP Digital Toolboxes for MB, NB, DWH, and Telemetry

Cloud + On-Prem + 3rd Party Service Integration

Enable scalable, intelligent decision-making via MCP-based context propagation.

6. Methods/Tools to be Used

Golang for MCP Server

Python for ML models

REST & gRPC APIs for agent communication

Redis/Postgres for context/session mgmt

Kafka/PubSub for task orchestration

Cloud Deployment: GCP, Azure

Telemetry: OTEL APIs, Prometheus/Grafana

7. Possible Outcomes

Real-time, scalable fraud detection, credit scoring, and AI guardrails

Seamless coordination between banking apps and backend ML/agent infra

A future-ready, explainable, modular AI banking stack

Research contribution: AI x BFSI orchestration model with MCP + Agent Mesh



MCP Server Generation Prompt (for Cursor, Copilot, GPT, etc.)

Build a complete MCP (Model Context Protocol) server in Golang for an AI Banking system using Agentic AI and ML models.
This MCP server will act as the orchestration layer that enables secure, modular, and context-aware routing of tasks between consumer banking apps and backend agentic AI infrastructure.

Architecture Reference:

The architecture consists of:

Consumer / Enterprise Applications (MB App, NB App, Trade App, Business App)

Intelligent AI Agent Services (API Lifecycle, API Security, Rate Limiting, Policy Mgmt)

AI SKIN Orchestrator (Input/Output Context, Task Mgmt, Session Mgmt, Rule Mgmt)

Agentic Mesh (Banking Agent, Payment Agent, Clearance Agent, Trade Agent, Auth Agent, Guardrail Agent)

MCP Digital Tool Foundry with Toolboxes for MB, NB, DWH, Telemetry (using APIs like Balance API, FT API, DT API, OTEL API)

Integration with Cloud (GCP, AWS, Azure), On-Premise, and 3rd Party Services

Project Requirements:
ğŸ—ï¸ 1. Architecture

Use Golang with modular architecture:

/cmd
/internal
  /controller
  /service
  /router
  /model
  /middleware
  /utils
  /config
/proto (for gRPC)
main.go

ğŸŒ 2. Exposed APIs (via REST & gRPC)

/submit-task â†’ Accept task from MB/NB/Trade apps with metadata and context

/register-agent â†’ Register new agent into mesh with role, rules, health info

/route-task â†’ Internally used by orchestrator to forward to proper agent (based on context/rules)

/get-result/{taskID} â†’ Fetch result/status

/get-session/{sessionID} â†’ Get full session data and context flow

/rules/upload â†’ Upload routing/rule JSON/YAML for orchestrator

ğŸ§  3. Core Components

SessionManager â†’ Track active requests, context, and session metadata

ContextRouter â†’ Resolve which agent/toolbox to route based on task input & business rules

AgentRegistry â†’ Store agent metadata (health, types, endpoint info)

RuleEngine â†’ Match input context to routing/action logic

TaskManager â†’ Persist task status, result, failure handling

ğŸ” 4. Security & Governance

API Key-based security with RBAC (for admin vs agents vs apps)

Logging with structured logs using Logrus/Zap

Basic rate limiting middleware

ğŸ› ï¸ 5. Tools/Dependencies

HTTP framework: Gorilla Mux or Fiber

gRPC: For agent communication

Database: Postgres or Redis (context/session persistence)

Broker (optional): Kafka or NATS for async task routing

Config: Viper or .env handling

Testing: GoMock, testify for unit testing

ğŸ“¦ 6. Sample Agent Payloads
{
  "agent_id": "fraud-checker-001",
  "task": "check_transaction",
  "input_context": {
    "account_id": "123456",
    "txn_amount": 5000,
    "channel": "NB"
  },
  "session_id": "sess_abc_123"
}

ğŸ§ª 7. Simulate and mock responses from:

Payment agent

Clearance agent

Guardrail agent

DWH toolbox

Generate the full Golang project scaffold with comments, modular files, and one working flow (submit task â†’ route to agent â†’ get result).



Architecture Overview (High-Level Description)

The overall architecture of the proposed AI Banking Platform using Agentic AI and MCP Servers is designed as a multi-layered, context-aware, intelligent processing ecosystem that unifies all banking channelsâ€”Mobile Banking (MB), Net Banking (NB), Enterprise Apps, and backend core systems. At the center of the system is the MCP Server, developed in Golang, which acts as the universal orchestration and coordination layer responsible for context management, agent selection, task routing, and inter-service communication. All user interactions, request payloads, telemetry signals, and risk indicators flow through the AI SKIN Layer, which enriches every event with contextual metadata before forwarding it to the MCP. The MCP Server interacts with an Agentic Mesh, a distributed collection of specialized AI agents such as the Fraud Detection Agent, Guardrail Agent, Credit Scoring Agent, Recommendation Agent, and Transaction Clearance Agent. These agents operate collaboratively using a shared context, probabilistic scoring models, and LLM reasoning to produce intelligent outcomes in real time. Communication across all components uses REST, gRPC, Kafka/PubSub, and Redis for low-latency state management. The system is fully instrumented with OpenTelemetry, enabling traceability, explainability, and monitoring across the entire pipeline. This architecture enables banks to deliver hyper-personalized services, real-time fraud prevention, seamless decisioning, and adaptive user experiences â€” all coordinated by a unified, intelligent MCP-driven AI orchestration layer.



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Requests (MB App, NB App, API)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: AI Skin Orchestrator (Port 8081)     â”‚
â”‚  - Natural Language Understanding               â”‚
â”‚  - Intent Recognition                           â”‚
â”‚  - Context Enrichment                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: MCP Server (Port 8080)                â”‚
â”‚  - Task Orchestration                           â”‚
â”‚  - Agent Routing                                â”‚
â”‚  - Session Management                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: Agent Mesh (Ports 8001-8005)          â”‚
â”‚  - Banking Agent                                â”‚
â”‚  - Fraud Agent                                  â”‚
â”‚  - Guardrail Agent                              â”‚
â”‚  - Clearance Agent                              â”‚
â”‚  - Scoring Agent                                â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                      â”‚
       v                      v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 4:     â”‚    â”‚ Layer 5:                    â”‚
â”‚ ML Models    â”‚    â”‚ Banking Integrations        â”‚
â”‚ (Port 9000)  â”‚    â”‚ (Port 7000)                 â”‚
â”‚              â”‚    â”‚                             â”‚
â”‚ - Fraud      â”‚    â”‚ - Mobile Banking (MB)       â”‚
â”‚ - Credit     â”‚    â”‚ - Net Banking (NB)          â”‚
â”‚ - Risk       â”‚    â”‚ - Data Warehouse (DWH)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜